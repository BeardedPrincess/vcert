package cloud

import (
	"encoding/json"
	"fmt"
	"golang.org/x/net/context"
	"log"
	"time"

	"github.com/google/uuid"

	"github.com/Venafi/vcert/v5/internal/datasource/cloudkeystores"
	"github.com/Venafi/vcert/v5/pkg/endpoint"
	"github.com/Venafi/vcert/v5/pkg/util"
	"github.com/Venafi/vcert/v5/pkg/websocket"
)

type CloudKeystoreProvisioningResult struct {
	Arn                        string `json:"arn"`
	CloudProviderCertificateID string `json:"cloudProviderCertificateId"`
	CloudCertificateName       string `json:"cloudProviderCertificateName"`
	CloudCertificateVersion    string `json:"cloudProviderCertificateVersion"`
	Error                      error  `json:"error"`
}

type CloudProvisioningMetadata struct {
	awsMetadata   CloudAwsMetadata
	azureMetadata CloudAzureMetadata
	gcpMetadata   CloudGcpMetadata
}

func (cpm *CloudProvisioningMetadata) GetAWSCertificateMetadata() endpoint.AWSCertificateMetadata {
	return &cpm.awsMetadata
}

func (cpm *CloudProvisioningMetadata) GetAzureCertificateMetadata() endpoint.AzureCertificateMetadata {
	return &cpm.azureMetadata
}

func (cpm *CloudProvisioningMetadata) GetGCPCertificateMetadata() endpoint.GCPCertificateMetadata {
	return &cpm.gcpMetadata
}

type CloudAwsMetadata struct {
	result CloudKeystoreProvisioningResult
}

func (cawm *CloudAwsMetadata) GetARN() string {
	return cawm.result.Arn
}

type CloudGcpMetadata struct {
	result CloudKeystoreProvisioningResult
}

func (cgm *CloudGcpMetadata) GetID() string {
	return cgm.result.CloudProviderCertificateID
}

func (cgm *CloudGcpMetadata) GetName() string {
	return cgm.result.CloudCertificateName
}

type CloudAzureMetadata struct {
	result CloudKeystoreProvisioningResult
}

func (cam *CloudAzureMetadata) GetName() string {
	return cam.result.CloudCertificateName
}

func (cam *CloudAzureMetadata) GetVersion() string {
	return cam.result.CloudCertificateVersion
}

func (cam *CloudAzureMetadata) GetID() string {
	return cam.result.CloudProviderCertificateID
}

// GCMCertificateScope Indicates the Scope for a certificate provisioned to GCP Certificate Manager
type GCMCertificateScope string

const (
	// GCMCertificateScopeDefault Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	GCMCertificateScopeDefault GCMCertificateScope = "DEFAULT"
	// GCMCertificateScopeEdgeCache Certificates with scope EDGE_CACHE are special-purposed certificates,
	// served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	GCMCertificateScopeEdgeCache GCMCertificateScope = "EDGE_CACHE"
)

type CertificateTagOption struct {
	Name  string
	Value string
}

type CloudProvisioningAzureOptions struct {
	Name       *string
	Enabled    *bool
	Exportable *bool
	Reusekey   *bool
	Tags       []*CertificateTagOption
}

func (cpao CloudProvisioningAzureOptions) GetType() string {
	return "AKV"
}

type CloudProvisioningGCPOptions struct {
	ID          *string
	Description *string
	Scope       *GCMCertificateScope
	Labels      []*CertificateTagOption
}

func (cpgo CloudProvisioningGCPOptions) GetType() string {
	return "GCM"
}

func (c *Connector) ProvisionCertificate(req *endpoint.ProvisioningRequest, options *endpoint.ProvisioningOptions) (provisioningMetadata endpoint.ProvisioningMetadata, err error) {
	log.Printf("Starting Provisioning Flow")

	if req == nil {
		return nil, fmt.Errorf("missing Provisioning Request")
	}

	reqData := *req

	if reqData.Timeout == 0 {
		reqData.Timeout = util.DefaultTimeout * time.Second
	}

	if reqData.KeystoreID == nil {
		return nil, fmt.Errorf("keystore ID was not provided for provisioning")
	}
	keystoreIDString := *(reqData.KeystoreID)
	log.Printf("Keystore ID for provisioning: %s", keystoreIDString)

	if reqData.CertificateID == nil {
		if reqData.PickupID == nil {
			return nil, fmt.Errorf("neither Certificate ID or Pickup ID was provided for provisioning")
		}
		log.Printf("Certificate ID was not provided in request. Fetching it by using Pickup ID %s", *(reqData.PickupID))
		certID, err := c.getCertIDFromPickupID(*(reqData.PickupID), reqData.Timeout)
		if err != nil {
			return nil, err
		}
		reqData.CertificateID = certID
	}
	certificateIDString := *(reqData.CertificateID)
	log.Printf("Certificate ID for provisioning: %s", certificateIDString)

	// Is certificate generated by VCP?
	log.Printf("Validating if certificate is generated by VCP")
	err = c.validateIfCertIsVCPGeneratedByID(*(reqData.CertificateID))
	if err != nil {
		return nil, err
	}
	log.Println("Certificate is valid for provisioning (VCP generated)")

	// setting options for provisioning
	log.Println("setting provisioning options")
	provisioningOptions, err := setProvisioningOptions(options)
	if err != nil {
		return nil, err
	}
	log.Println("provisioning options successfully set")

	graphqlClient := c.getGraphqlClient()

	ctx := context.Background()

	// Getting Keystore to find type
	log.Printf("fetching keystore information for KeystoreID: %s", keystoreIDString)
	data, err := cloudkeystores.GetCloudKeystoresByKeystoreId(ctx, graphqlClient, req.KeystoreID)
	if err != nil {
		return nil, err
	}

	if len(data.CloudKeystores.Nodes) == 0 {
		return nil, fmt.Errorf("could not find keystore with ID: %s", keystoreIDString)
	}

	if len(data.CloudKeystores.Nodes) > 1 {
		return nil, fmt.Errorf("found more than one keystore for ID: %s", keystoreIDString)
	}

	// grabbing found keystore for later
	cloudKeystore := data.CloudKeystores.Nodes[0]
	log.Printf("successfully fetched keystore information for KeystoreID: %s", keystoreIDString)

	wsClientID := uuid.New().String()

	wsConn, err := websocket.Subscribe(c.apiKey, c.baseURL, wsClientID)
	if err != nil {
		return nil, err
	}

	log.Printf("Provisioning Certificate ID %s for Keystore %s", certificateIDString, keystoreIDString)
	_, err = cloudkeystores.ProvisionCertificate(ctx, graphqlClient, certificateIDString, keystoreIDString, wsClientID, provisioningOptions)
	if err != nil {
		return nil, err
	}

	ar, err := websocket.ReadResponse(wsConn)
	if err != nil {
		return nil, err
	}

	// parsing metadata from websocket response
	log.Printf("Getting Cloud Metadata of Certificate ID %s and Keystore ID: %s", certificateIDString, keystoreIDString)
	cloudMetadata, err := getCloudMetadataFromWebsocketResponse(ar.Data.Result, cloudKeystore.Type, keystoreIDString)
	if err != nil {
		return nil, err
	}
	log.Printf("Successfully got Cloud Metadata for Certificate ID %s and Keystore ID: %s", certificateIDString, keystoreIDString)

	log.Printf("Successfully finished Provisioning Flow for Certificate ID %s and Keystore ID %s", certificateIDString, keystoreIDString)
	return cloudMetadata, nil
}

func setProvisioningOptions(options *endpoint.ProvisioningOptions) (*cloudkeystores.CertificateProvisioningOptionsInput, error) {
	var cloudOptions *cloudkeystores.CertificateProvisioningOptionsInput
	dataOptions, err := json.Marshal(options)
	if err != nil {
		return nil, err
	}

	graphqlAzureOptions := &cloudkeystores.CertificateProvisioningAzureOptionsInput{}
	graphqlGCPOptions := &cloudkeystores.CertificateProvisioningGCPOptionsInput{}

	if options != nil {
		switch (*options).GetType() {
		case string(cloudkeystores.CloudKeystoreTypeAcm):
			// nothing
		case string(cloudkeystores.CloudKeystoreTypeAkv):
			err = json.Unmarshal(dataOptions, graphqlAzureOptions)
			if err != nil {
				return nil, err
			}
		case string(cloudkeystores.CloudKeystoreTypeGcm):
			err = json.Unmarshal(dataOptions, graphqlGCPOptions)
			if err != nil {
				return nil, err
			}
		default:
			return nil, fmt.Errorf("unknown cloud keystore type: %s", (*options).GetType())
		}
	}

	cloudOptions = &cloudkeystores.CertificateProvisioningOptionsInput{
		AwsOptions:   nil,
		AzureOptions: graphqlAzureOptions,
		GcpOptions:   graphqlGCPOptions,
	}
	return cloudOptions, nil
}
